/*
Warnings before you copy/paste this code:
- Pick a large enough array length.
- Make sure to initialise the array and fill in the unused entries.

Description:
Let f(a,b) be an associative function (e.g. min(a,b), max(a,b), a+b, etc...),
with identity IDENT. Let x[i] be some list of values (0-indexed) of length N.
An interval tree is a data structure that supports the following operations in
O(log N * f) time:
- set x[i] = v
- compute f( x[i], x[i+1], x[i+2], ..., x[j] ) for some i, j

Implementation:
Assume for the sake of simplicity that N is a power of 2. Construct an
array-based implicit binary tree called tree[i], where:
- Node i has parent i/2.
- Node i has children 2*i and 2*i+1
Let tree[i+N] = x[i], and let tree[j] = f( tree[2*j], tree[2*j+1] ) for j < N
and j >= 1. In other words, tree[N], tree[N+1], ..., tree[2*N-1] store the
`real' values of the entries in the array, while tree[j] (for 1 <= j < N)
aggregates f over all the children of j.

Using this structure, updating tree[i] and computing
f( x[i], x[i+1], x[i+2], ..., x[j] ) can be done efficiently.

Note: There exists another type of segment tree that allows ranges to be
modified in O(log N) time also, but this structure is much more complicated and
I haven't included the code in this file. Derive it for yourself.

Links:
http://codeforces.com/blog/entry/3327
*/

int tree[2*N];

void init()
{
	// MAKE SURE TO INITIALISE TREE PROPERLY
}

void update( int i, int v )
{
	i += N;
	tree[i] = v;
	for( i /= 2; i; i /= 2 ) tree[i] = f( tree[2*i], tree[2*i+1] );
}

int query( int i, int j )
{
	int ans = IDENT;
	for( i += N, j += N; i <= j; i = ( i + 1 ) / 2, j = ( j - 1 ) / 2 )
	{
		if( i % 2 == 1 ) ans = f( ans, tree[i] );
		if( j % 2 == 0 ) ans = f( ans, tree[j] );
	}
	return ans;
}
