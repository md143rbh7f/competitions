/*
	C++ and Java implementations of Ford-Fulkerson and Edmonds-Karp.
*/

// BEGIN JAVA

	int max_flow( int[][] cap, int s, int t )
	{
		int n = cap.length, flow[][] = new int[n][n];
		/*
		boolean[] seen = new boolean[n];
		do Arrays.fill( seen, false );
		while( max_flow_dfs( cap, flow, seen, s, t, INF ) > 0 );
		*/
		int[] prev = new int[n];
		do Arrays.fill( prev, -1 );
		while( max_flow_bfs( cap, flow, prev, s, t, INF ) > 0 );
		int max = 0;
		for( int i = 0; i < n; i++ ) max += flow[i][t];
		return max;
	}

	// Ford-Fulkerson
	int max_flow_dfs( int[][] cap, int[][] flow, boolean[] seen, int s, int t, int minflow )
	{
		if( s == t ) return minflow;
		if( seen[s] ) return 0;
		seen[s] = true;
		for( int i = 0; i < cap.length; i++ )
		{
			if( cap[s][i] == flow[s][i] ) continue;
			int minflow2 = Math.min( minflow, cap[s][i] - flow[s][i] );
			minflow2 = Math.min( minflow2, max_flow_dfs( cap, flow, seen, i, t, minflow2 ) );
			if( minflow2 > 0 )
			{
				flow[s][i] += minflow2;
				flow[i][s] -= minflow2;
				return minflow2;
			}
		}
		return 0;
	}

	// Edmonds-Karp
	int max_flow_bfs( int[][] cap, int[][] flow, int[] prev, int s, int t, int minflow )
	{
		LinkedList<Integer> q = new LinkedList<Integer>();
		prev[s] = -2;
		q.add( s );
		while( !q.isEmpty() )
		{
			int i = q.poll();
			for( int j = 0; j < cap.length; j++ ) if( cap[i][j] > flow[i][j] && prev[j] == -1 )
			{
				prev[j] = i;
				q.add( j );
			}
		}
		if( prev[t] == -1 ) return 0;
		int ans = cap[prev[t]][t] - flow[prev[t]][t];
		for( int v = t; prev[v] >= 0; v = prev[v] ) ans = Math.min( ans, cap[prev[v]][v] - flow[prev[v]][v] );
		for( int v = t; prev[v] >= 0; v = prev[v] )
		{
			flow[prev[v]][v] += ans;
			flow[v][prev[v]] -= ans;
		}
		return ans;
	}

// END JAVA

// BEGIN C++

// Edmonds-Karp
int bfs( int s, int t )
{
	list<int> q;
	prev[s] = -2;
	q.push_back(s);
	while( !q.empty() )
	{
		int i = *q.begin();
		q.pop_front();
		for( int j = 0; j < n; j++ ) if( g[i][j] > f[i][j] && prev[j] == -1 ) prev[j] = i, q.push_back( j );
	}
	if( prev[t] == -1 ) return 0;
	int ans = g[prev[t]][t] - f[prev[t]][t];
	for( int v = t; prev[v] >= 0; v = prev[v] ) ans = min( ans, g[prev[v]][v] - f[prev[v]][v] );
	for( int v = t; prev[v] >= 0; v = prev[v] ) f[prev[v]][v] += ans, f[v][prev[v]] -= ans;
	return ans;
}

// Ford-Fulkerson
int dfs( int s, int t, int minf )
{
	if( s == t ) return minf;
	if( seen[s] ) return 0;
	seen[s] = true;
	for( int i = 0; i < n; i++ )
	{
		if( g[s][i] == f[s][i] ) continue;
		int minf2 = min( minf, g[s][i] - f[s][i] );
		minf2 = min( minf2, dfs( i, t, minf2 ) );
		if( minf2 )
		{
			f[s][i] += minf2, f[i][s] -= minf2;
			return minf2;
		}
	}
	return 0;
}

int max_flow( int s, int t )
{
	for( int i = 0; i < n; i++ ) for( int j = 0; j < n; j++ ) f[i][j] = 0;
	//do for( int i = 0; i < n; i++ ) seen[i] = false;
	//while( dfs( s, t, INF ) );
	do for( int i = 0; i < n; i++ ) prev[i] = -1;
	while( bfs( s, t ) );
	int ans = 0;
	for( int i = 0; i < n; i++ ) ans += f[s][i];
	return ans;
}

// END C++
