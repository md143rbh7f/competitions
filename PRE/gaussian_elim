/*
	Runs Gaussian elimination on a square matrix to solve the equation A x = b for x.
	Can be modified to run on non-square matrices.
*/

// BEGIN C++

	rep(i,N)
	{
		REP(j,i,N)
		if( abs(a[j][i])>=EPS )
		{
			REP(k,i,N+1)
			{
				double t = a[i][k];
				a[i][k] = a[j][k];
				a[j][k] = t;
			}
			break;
		}
		double r = a[i][i];
		REP(k,i,N+1) a[i][k] /= r;
		rep(j,N)
		if( j!=i && abs(a[j][i])>=EPS )
		{
			r = a[j][i];
			REP(k,i,N+1) a[j][k] -= r*a[i][k];
		}
	}

// END C++

// BEGIN JAVA

	static double[] gaussian_elim( double[][] A, double[] b )
	{
		int n = A.length;
		double a[][] = new double[n][n+1], temp[], scale;
		for( int i = 0; i < n; i++ ) for( int j = 0; j < n; j++ ) a[i][j] = A[i][j];
		for( int i = 0; i < n; i++ ) a[i][n] = b[i];
		for( int i = 0; i < n; i++ )
		{
			for( int j = i; j < n; j++ )
				if( Math.abs(a[j][i])>EPS )
				{
					// swap rows
					temp = a[j];
					a[j] = a[i];
					a[i] = temp;
					break;
				}
			// scale a[i] by 1/a[i][i]
			scale = 1/a[i][i];
			for( int j = i; j <= n; j++ ) a[i][j] *= scale;
			for( int j = 0; j < n; j++ )
				if( i != j && Math.abs(a[j][i])>EPS )
				{
					// add -a[j][i]*a[i] to a[j]
					scale = -a[j][i];
					for( int k = i; k <= n; k++ ) a[j][k] += scale*a[i][k];
				}
		}
		double[] x = new double[n];
		for( int i = 0; i < n; i++ ) x[i] = a[i][n];
		return x;
	}

	// The following code performs gaussian elimination on matrix modulo p, for a prime p.
	// Note: memoizes the inverse mod p
	static int[] gaussian_elim_mod( int[][] A, int[] b, int p )
	{
		int n = A.length;
		int a[][] = new int[n][n+1], temp[], scale, inv[] = new int[p];
		inv[1] = 1;
		for( int i = 2; i < p; i++ ) inv[i] = -1;
		for( int i = 0; i < n; i++ ) for( int j = 0; j < n; j++ ) a[i][j] = A[i][j];
		for( int i = 0; i < n; i++ ) a[i][n] = b[i];
		for( int i = 0; i < n; i++ )
		{
			for( int j = i; j < n; j++ )
				if( a[j][i] != 0 )
				{
					// swap rows
					temp = a[j];
					a[j] = a[i];
					a[i] = temp;
					break;
				}
			// scale a[i] by 1/a[i][i]
			if( inv[a[i][i]]==-1 )
			{
				inv[a[i][i]] = modulo_inverse(a[i][i],p);
				inv[inv[a[i][i]]] = a[i][i];
			}
			scale = inv[a[i][i]];
			for( int j = i; j <= n; j++ ) a[i][j] = (scale*a[i][j])%p;
			for( int j = 0; j < n; j++ )
				if( i != j && a[j][i] != 0 )
				{
					// add -a[j][i]*a[i] to a[j]
					scale = p-a[j][i];
					for( int k = i; k <= n; k++ ) a[j][k] = (a[j][k]+scale*a[i][k])%p;
				}
		}
		int[] x = new int[n];
		for( int i = 0; i < n; i++ ) x[i] = a[i][n];
		return x;
	}

// END JAVA
